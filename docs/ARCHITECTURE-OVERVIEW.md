# OpenNet architecture overview

This document summarizes the architecture of OpenNet to help new contributors (and Claude Code) understand how the pieces fit together.

It is intentionally high‑level; for more detailed explanations, see the original OpenNet paper and the project tutorial in `doc/TUTORIAL.md`.

---

## 1. Design goals

OpenNet is designed to simulate **software‑defined wireless local area networks (SD‑WLANs)** by combining:

- The **control‑plane realism** of Mininet (running real OpenFlow/SDN controllers and switch processes).
- The **data‑plane and wireless realism** of ns‑3 (packet‑level models of Wi‑Fi, LTE, channel conditions, mobility, etc.).

It aims to:

- Let researchers prototype SDN controller logic in Mininet while seeing realistic wireless behavior from ns‑3.
- Support Wi‑Fi and LTE handover, channel scanning, and mobility.
- Scale to larger topologies via distributed emulation and, optionally, time‑dilated simulation.

---

## 2. Key components

### 2.1 Mininet side

- **Mininet core**  
  - Emulates hosts and switches using Linux namespaces, veth pairs, and Open vSwitch.
  - Runs real SDN controllers and control protocols (e.g., OpenFlow) as normal processes.

- **OpenNet‑specific extensions in Mininet** (inside the `mininet/` fork):

  - `mininet/mininet/ns3.py`  
    - Provides an interface from Mininet to ns‑3 Wi‑Fi emulation.
    - Responsible for mapping Mininet hosts / interfaces to ns‑3 nodes and devices.

  - `mininet/mininet/wifi.py`  
    - Handles distributed Wi‑Fi emulation.
    - Coordinates Mininet host placement vs. ns‑3 Wi‑Fi topology.

  - `mininet/mininet/lte.py`  
    - Handles LTE emulation and backhaul logic, steering flows into ns‑3 LTE models.

  - `mininet/mininet/opennet.py`  
    - Utility functions for OpenNet‑specific tasks (e.g., NetAnim hooks, pcap capture).

  - `mininet/bin/opennet-agent.py`  
    - A TCP daemon used to coordinate **distributed ns‑3 emulation** across multiple machines.
    - Receives commands from a controller node and triggers actions on worker nodes.

  - `mininet/examples/opennet/*.py`  
    - Example topologies and scenarios combining Mininet and ns‑3 (Wi‑Fi roaming, LTE backhaul, etc.).

### 2.2 ns‑3 side

- **Base ns‑3 modules** (from `ns-allinone-3.xx`):
  - Wi‑Fi, CSMA, LTE, mobility, NetAnim, etc.

- **OpenNet patches in `ns3-patch/`**:

  - `sta-wifi-scan.patch`  
    - Enhances ns‑3’s Wi‑Fi station model to support channel scanning behavior that is important for SD‑WLAN experiments.

  - `animation-interface.patch` and `netanim-python.patch`  
    - Extend NetAnim to visualize `CsmaLink` and `SimpleLink` objects.
    - Improve Python integration for animation / visualization.

  - `lte.patch`  
    - Adds SDN‑based LTE backhaul behavior.
    - Provides hooks that connect LTE data paths to Mininet / OpenNet’s SDN logic.
    - Integrates with time‑dilation support when enabled.

### 2.3 Time dilation (optional)

- **VirtualTimeForMininet**  
  - A patched Linux kernel (historically 3.16.3) that allows Mininet processes to run under a virtualized notion of time.
  - Enables experiments where wall‑clock time is slowed relative to simulated time, making it easier to run large‑scale or high‑traffic scenarios without overloading the host.

- **ns‑3 time dilation hooks** (part of the LTE and possibly Wi‑Fi patches)  
  - Ensure that ns‑3’s notion of time is consistent with Mininet’s virtual time when the virtual‑time kernel is used.

In the modernized version, time dilation is treated as an **advanced, opt‑in feature** that may require a dedicated VM or container.

---

## 3. Data path and control path

### 3.1 Control path

1. SDN controllers run as normal processes on the Mininet host (e.g., in network namespaces).
2. Switches (Open vSwitch instances) connect to controllers using standard control protocols.
3. OpenNet does **not** modify controller code; it simply provides a more realistic data plane via ns‑3.

### 3.2 Data path

1. Packets generated by Mininet hosts destined for wireless links are mapped into ns‑3 via the OpenNet integrations.
2. Inside ns‑3:
   - Packets traverse Wi‑Fi / LTE / CSMA models, taking into account:
     - Channel conditions, interference, and propagation.
     - Mobility and handover logic.
     - Backhaul topology (e.g., LTE backhaul to an SDN core).
3. At the edge of the ns‑3 network, packets re‑enter the Mininet environment via tap devices or similar bridging mechanisms.
4. NetAnim and pcap capture can be used to visualize and debug the resulting data plane behavior.

---

## 4. Deployment and scaling

### 4.1 Single‑node deployment

- All components (Mininet, ns‑3, controllers) run on a single physical machine.
- Suitable for small to medium testbeds and most classroom labs.
- Time dilation can be used here to stretch simulated time relative to real time if desired.

### 4.2 Distributed deployment

- Multiple physical machines:
  - One or more running Mininet and controllers.
  - One or more running ns‑3 instances.
- `opennet-agent.py` coordinates operations across nodes using TCP.
- Ansible playbooks in `ansible/` can be used to:
  - Install dependencies on all nodes.
  - Configure SSH access and environment variables.
  - Start and stop OpenNet services in a repeatable way.

Scaling considerations:

- CPU and memory usage from ns‑3 simulations (especially LTE) can be high.
- Time dilation can help keep CPU usage manageable at the cost of longer wall‑clock experiments.
- Network connectivity between nodes (e.g., over a lab LAN) shapes performance and realism.

---

## 5. Modernization considerations

When modernizing the project for Ubuntu 22.04:

- Keep this high‑level architecture intact.
- Avoid conflating **research logic** (Wi‑Fi scan, LTE backhaul, NetAnim visualization, time dilation) with **deployment glue** (install scripts, Ansible, Docker, CI).
- Make sure new scripts and containers:
  - Preserve the same conceptual topology and data path.
  - Provide clear defaults (single‑node, no time dilation).
  - Allow advanced users to enable distributed mode and time dilation with explicit configuration.

This overview is intentionally concise; expand it with diagrams, sequence charts, or more detailed module descriptions as the modernization progresses.
